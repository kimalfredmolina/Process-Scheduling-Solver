<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CPU Scheduling TUtorial</title>
    <link rel="icon" type="image/png" href="logoa.png">
    <link rel="stylesheet" href="infostyle.css" />
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-GLhlTQ8iRABdZLl6O3oVMWSktQOp6b7In1Zl3/Jr59b6EGGoI1aFkw7cmDA6j6gD" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css" />
  </head>
  <body>
    <nav class="sidebar">
      <a href="index.html" class="logo">Home</a>

      <div class="menu-content">
        <ul class="menu-items">

          <li class="item">
            <a href="#">CPU Scheduling</a>
          </li>

          <li class="item">
            <a href="#FCFS">First Come First Serve</a>
          </li>

          <li class="item">
            <a href="#SJF">Shortest Job First</a>
          </li>

          <li class="item">
            <a href="#SRTF">Shortest Remaining Time First</a>
          </li>
          
          <li class="item">
            <a href="#PRIO">Priority (Preemptive)</a>
          </li>

          <li class="item">
            <a href="#NON-PRIO">Priority (Non-Preemptive)</a>
          </li>

          <li class="item">
            <a href="#RR">Round-Robin</a>
          </li>

          <li class="item">
            <div class="submenu-item">
              <span>Process Calculator</span>
              <i class="fa-solid fa-chevron-right"></i>
            </div>
            <ul class="menu-items submenu">
              <div class="menu-title">
                <i class="fa-solid fa-chevron-left"></i>
                Tutorial
              </div>
              <li class="item">
                <a href="fcfs.html">First Come First Serve</a>
              </li>

              <li class="item">
                <a href="sjf.html">Shortest-Job-First</a>
              </li>

              <li class="item">
                <a href="srtf.html">Shortest-Remaining-Time-First</a>
              </li>

              <li class="item">
                <a href="Prio p.html">Priority (Preemptive)</a>
              </li>

              <li class="item">
                <a href="Prio np.html">Priority (Non-Preemptive)</a>
              </li>

              <li class="item">
                <a href="rr.html">Round Robin</a>
              </li>
            </ul>
          </li>

        </ul>
      </div>
    </nav>

    <nav class="navbar">
      <i class="fa-solid fa-bars" id="sidebar-close"></i>
    </nav>
    <main class="main">
      <div class="container">
        <div class="wrapper">
          <img class ="cpu" src="CPU-Scheduling.jpg" alt="cpu">
          <div class="cpu-text">
          <h1>What is <br>  CPU-Scheduling?</h1>
          <p>
            CPU scheduling, a critical component of process management, facilitates the efficient utilization of the CPU by allowing processes to execute while others are temporarily delayed due to resource unavailability such as I/O operations. Its primary objective is to ensure timely completion of tasks, enhancing system efficiency, speed, and fairness. When the CPU is idle, the operating system employs a temporary scheduler to select the next process from the queue of ready processes awaiting execution. This scheduler evaluates the readiness of each process in memory and allocates the CPU to the most suitable candidate, thereby optimizing resource utilization and overall system performance.
          </p>
          </div>
        </div>
      </div>
    </main>

    <style>
      h2 {
        color: rgb(252, 0, 0);
      }
    </style>

    <section class="container py-5" id="FCFS">
      <div class="row mt-4 py-3">
        <div class="col-12 d-flex flex-column text-right justify-content-right" id="paragraph">
          <h2>First Come First Serve</h2>  
          <h5 class="text-secondary fw-normal py-2 Lucida Console">The simplest CPU scheduling algorithm, FCFS (First Come, First Serve), prioritizes processes based on their arrival times, utilizing a FIFO queue. As processes enter the ready queue, their PCBs are appended to the queue's tail. When the CPU becomes available, the process at the head of the queue is allocated the CPU and subsequently removed from the queue. FCFS can be either preemptive or non-preemptive, executing tasks in the order they arrive. While easy to implement, FCFS may result in high wait times and is less efficient, making it better suited for batch systems where longer process durations are tolerable.</h5>
            <img class = fcfspic src="FCFS-PIC.png" alt="fcfspic">
            <h5>So let's work on some examples from the given picture above and break it down bit by bit.</h5>
            <ul class="steps">
              <h2>Gantt Chart</h2>
              <li>The first would be to solve for the completion time, and this can be done by using a gantt chart. With both the arrival time and the given time, we could use that for the gantt chart.</li>
              <li>So using the arrival time of the processes, we have to process the one who came earlier, so it's going to be <b>J1</b> as it's the one who came first with the arrival time of 0.</li>
              <li>Then we have to process the <b>J1</b> with its burst time of 8.</li>
              <li>After we processed the first job, as you can see, we ended it at 8. Within those 8 came 2 jobs, which were <b>J3</b> and <b>J5</b>, which have a burst time of 7 and 4, respectively.</li>
              <li>To know which one to process first in a queue of jobs in the <b> First Come First Serve Algorithm </b> we have to use the arrival time of the queued jobs.</li>
              <li>In this case we would process the <b>J5</b> first because it arrived much earlier than the <b>J3</b>.</li>
              <li>Then we would use all of the burst time of <b>J5</b>, and the process ended at 9, then another job arrived, which is the j4.</li>
              <li>Using the same criteria we used earlier for multiple queued jobs, we would process the one who arrived first, which in this case is <b>J3</b>, which ended at 16. Inside those 16 then arrived another job, which is <b>J2</b>.</li>
              <li>Then we'll use the criteria again, which in this case is <b>J4</b> because it arrived first than <b>j2</b>. After we processed <b>J4</b>, which ended at 21, no other job arrived, so we will process the remaining job, <b>J2</b>, which ended at 30.</li>
              <h2>Turnaround Time and Waiting Time</h2>
              <h4>Turnaround-Time</h4>
              <li>Now that our Gantt chart is done, we can now solve the remaining parts of the table, which are the <b>turnaround time and waiting time.</b></li>
              <li>First would be the <b>turnaround time</b>, which we can solve by subtracting the <b>completion time</b> of the job from its <b>arrival time</b>.</li>
              <li>Now that we know the equation for the turnaround time, we can now calculate the turnaround time for each job.</li>
              <li>So we have <b>J1</b>, which has an <b>arrival time of 0</b> and a <b>completion time of 8</b>. Using the formula for the <b>turnaround-time (0-8)</b>, the answer would be 8. Now do the same for the others. <b>J2 = (10 - 30 = 20), J3 = (7 - 16 = 9), J4 = ( 9 - 21 = 12), J5 = (4 - 9 = 5)</b>.</li>
              <li>Now that we got the <b>turnaround-time</b> of all of the jobs we can now calculate the waiting time of each job. This is done by subtracting the <b>turnaround-time and the burst time</b> of each jobs</li>
              <h4>Waiting Time</h4>
              <li>With that, let's calculate the <b>waiting time</b> for each job.</li>
              <li>For <b>J1</b>, we can see that it has a <b>turnaround time of 8 and a burst time of 8</b>. By subtracting those two, we get a 0 as an answer.Now lets do the rest of the jobs.</li>
              <li>For <b>J2</b>,it has a <b>turnaround time of 20</b> and a <b>burst time of 9 </b>so <b>J2 = (20 - 9 = 11)</b><b>J3 = (9 - 7 = 2), j4 = (12 - 5 = 7), j5 = (5 - 1 =4)</b></li>
              <h2>Average turnaround time, average waiting time, CPU Utilization</h2>
              <img class="fcfsavg" src="FCFS-AVG.png" alt="fcfsavg">
              <h4>Average turnaround time</h4>
              <li>The calculations for the <b>Average turnaround time</b> are as follows: get the summation of <b>turnaround time</b> and divide the sum by how many items are there. In this case, the summation of <b>turnaround time is 54 divided by 5, which gives us 10.8</b>.</li>
              <li>Next is the <b>average waiting time</b>. It's just as simple: we're going to do the same thing as we did for the average turnaround time. so it will be the summation of <b>Waiting time 24 divided by 5, which gives us 4.8 as the answer</b></li>
              <li>Now for the CPU utilization. In this one, we are going to need the sum of our burst time, divide it by our total completion time, and multiply it by 100. So in this case, the <b>summation of burst time is 30; divide it by our end time, which is 30; then multiply by 100</b>, we get a total of <b>100% CPU-Utilization</b>.</li>
            </ul>
          </div>
        </div>
      </div>
    </section>

    <section class="container py-5" id="SJF">
      <div class="row mt-4 py-3">
        <div class="col-12 d-flex flex-column text-right justify-content-right" id="paragraph">
          <h2>Shortest Job First</h2>  
          <h5 class="text-secondary fw-normal py-2 Lucida Console">The Shortest Job First (SJF) or Shortest Job Next (SJN) is a scheduling policy that prioritizes the process with the smallest execution time. This can be either preemptive or non-preemptive. It’s a Greedy Algorithm known for its minimal average waiting time among all scheduling algorithms. However, it may lead to starvation if shorter processes continually arrive, which can be mitigated using the concept of ageing. While it’s practically challenging to implement as the Operating System may not know burst times, several methods, like a weighted average of previous execution times, can estimate a job’s execution time. This makes SJF suitable for specialized environments where accurate running time estimates are available. The algorithm works by sorting all processes according to their arrival time, then selecting the process with the minimum arrival and burst time. After a process is completed, a pool of processes that arrive afterward is created, and the process with the minimum burst time is selected from this pool. </h5>
            <img class = fcfspic src="shortest job first.png" alt="fcfspic">
            <h5>So let's work on some examples for Shortest Job First from the given picture above and break it down bit by bit.</h5>
            <ul class="steps">
              <h2>Gantt Chart</h2>
              <li>As we did in the first come, first serve algorithm, we would <b>create a Gantt chart based on the arrival and burst time of our jobs.</b></li>
              <li>Although it's almost the same, it has a different way of doing its priority compared to the <b>first come, first serve</b>.</li>
              <li><b>Shortest Job First uses burst time</b> to know which to process next if there are multiple jobs on the ram.</li>
              <li>So with that in mind we can now create a gantt chart for our <b>Shortest Jobs First Algorithm</b>.</li>
              <li>Back to the table, we can see that <b>J1 arrived first</b> and no other jobs are in the ram, so now we have to process j1 all the way.</li>
              <li>Now that we have a <b>burst time of 8, J3 and J5 arrived.</b></li>
              <li>And now we can use the criteria for <b>Shortest Job First</b>, which is that <b>when there are more than 1 process inside the ram</b>, the one who will be <b>processed first is the one with the lowest burst time.</b></li>
              <li>In this case, based on the table above, <b>J5 has a lower burst time than J3, so J5 will be processed first.</b> After we processed that we were at 9 m/s,  another job arrived, which is the <b>J4</b>.</li>
              <li>So by utilizing the criteria again, <b>we will process J4 first as it has a lower burst time than J3 in the queue</b> ending at 14 then comes <b>J2. Now we will process J3 as it has a lower burst time than j2</b>ending at 21, and lastly, we will now process <b>J2 and end at 30 m/s.</b></j2></li>
              <h2>Turnaround Time and Waiting Time</h2>
              <h4>Turnaround-Time</h4>
              <li>Now that our Gantt chart is done, we can now solve the remaining parts of the table, which are the <b>turnaround time and waiting time.</b></li>
              <li>First would be the <b>turnaround time</b>, which we can solve by subtracting the <b>completion time</b> of the job from its <b>arrival time</b>.</li>
              <li>Now that we know the equation for the turnaround time, we can now calculate the turnaround time for each job.</li>
              <li>So we have <b>J1</b>, which has an <b>arrival time of 0</b> and a <b>completion time of 8</b>. Using the formula for the <b>turnaround-time (0-8)</b>, the answer would be 8. Now do the same for the others. <b>J2 = (10 - 30 = 20), J3 = (7 - 21 = 14), J4 = ( 9 - 14 = 5), J5 = (4 - 9 = 5)</b>.</li>
              <li>Now that we got the <b>turnaround-time</b> of all of the jobs we can now calculate the waiting time of each job. This is done by subtracting the <b>turnaround-time and the burst time</b> of each jobs</li>
              <h4>Waiting Time</h4>
              <li>With that, let's calculate the <b>waiting time</b> for each job.</li>
              <li>For <b>J1</b>, we can see that it has a <b>turnaround time of 8 and a burst time of 8</b>. By subtracting those two, we get a 0 as an answer.Now lets do the rest of the jobs.</li>
              <li>For <b>J2</b>,it has a <b>turnaround time of 20</b> and a <b>burst time of 9 </b>so <b>J2 = (20 - 9 = 11)</b><b>J3 = (14 - 7 = 7), j4 = (5 - 5 = 0), j5 = (5 - 1 = 4)</b></li>
              <h2>Average turnaround time, average waiting time, CPU Utilization</h2>
              <img class="fcfsavg" src="sjf avg.png" alt="fcfsavg">
              <h4>Average turnaround time</h4>
              <li>The calculations for the <b>Average turnaround time</b> are as follows: get the summation of <b>turnaround time</b> and divide the sum by how many items are there. In this case, the summation of <b>turnaround time is 52 divided by 5, which gives us 10.4</b>.</li>
              <li>Next is the <b>average waiting time</b>. It's just as simple: we're going to do the same thing as we did for the average turnaround time. so it will be the summation of <b>Waiting time 22 divided by 5, which gives us 4.4 as the answer</b></li>
              <li>Now for the CPU utilization. In this one, we are going to need the sum of our burst time, divide it by our total completion time, and multiply it by 100. So in this case, the <b>summation of burst time is 30; divide it by our end time, which is 30; then multiply by 100</b>, we get a total of <b>100% CPU-Utilization</b>.</li>
            </ul>
          </div>
        </div>
      </div>
    </section>

    <section class="container py-5" id="SRTF">
      <div class="row mt-4 py-3">
        <div class="col-12 d-flex flex-column text-right justify-content-right" id="paragraph">
          <h2>Shortest Remaining Time First</h2>  
          <h5 class="text-secondary fw-normal py-2 Lucida Console">The Shortest Remaining Time First (SRTF) is a preemptive version of the Shortest Job First (SJF) scheduling algorithm. Unlike SJF, which is non-preemptive and lets a process run to completion once started, SRTF can interrupt a running process if a new process with a shorter remaining time arrives. This leads to improved response times as shorter tasks get completed quickly. However, it also results in increased overhead due to frequent context switching and CPU time monitoring, unlike SJF which has less overhead but may not provide the best turnaround times for shorter tasks that arrive after a long task has started execution.</h5>
            <img class = fcfspic src="SRTF-PIC.png" alt="fcfspic">
            <h5>So let's work on some examples from the given picture above and break it down bit by bit.</h5>
            <ul class="steps">
              <h2>Gantt Chart</h2>
              <li>To make a gantt chart for the <b>SRTF, or shortest remaining time first</b>, it's basically the same as shortest job first; the only difference is that this scheduling algorithm is preemptive, meaning it has to stop processing the job if another job arrives while processing.</li>
              <li>Referring to the table above, we can see that <b>J1 arrived first,</b> so we will process it.</li>
              <li>Now, while it is processing, we can now <b>use the rule for the shortest remaining time first algorithm</b>, and that is, when a job arrives, <b>the current job that is being processed will come to a halt.</b></li>
              <li>So now <b>J1 will have to stop at time 4 because the job J5 arrived and we have to deduct the time used for J1 making its burst time 4</b>.Now that we have a queue, we would now have to look at the burst time to see which job to process first, much like Shortest Job First.</li>
              <li><b>J5 has a lower burst time than J1, so we have to process it first</b>. Using all of its burst time, we would stop at time 5, in which only J1 is in the queue. So we have to process J1 until time 7, deduct the 2 from its current burst time making it 2, and then <b>another job arrives, which is J3</b>.</li>
              <li>Again, we have multiple jobs in the queue, so we would have to check their burst time to see which is lower so that it can be processed first. In this case, it would be <b>J1 as it has only two burst time left</b> processing until time 9, at which time another job arrives, which is J4.</li>
              <li>We would have to <b>process J4 first as it has a lower burst time than J3</b>, We would only consume 1 of its burst time as <b>another job arrives at time 10, which is J2.</b></li>
              <li>Now that we have all the processes in the ram and there are no more jobs to arrive, we can now consume all of the burst time of the remaining jobs in the queue without stopping the process.</li>
              <li>Using the criteria again, <b>we can check each of their burst times to know which to process</b>. First, we will have to process J4 and consume its remaining time, which is 4, ending its process at time 14. Next is J3, which has a burst time of 7, ending at time 21, and lastly, the remaining job, which is J2, with a burst time of 9, ending at time 30.</li>
              <h2>Turnaround Time and Waiting Time</h2>
              <h4>Turnaround-Time</h4>  
              <li>Now that our Gantt chart is done, we can now solve the remaining parts of the table, which are the <b>turnaround time and waiting time.</b></li>
              <li>First would be the <b>turnaround time</b>, which we can solve by subtracting the <b>completion time</b> of the job from its <b>arrival time</b>.</li>
              <li>Now that we know the equation for the turnaround time, we can now calculate the turnaround time for each job.</li>
              <li>So we have <b>J1</b>, which has an <b>arrival time of 0</b> and a <b>completion time of 9</b>. Using the formula for the <b>turnaround-time (0-9)</b>, the answer would be 9. Now do the same for the others. <b>J2 = (10 - 30 = 20), J3 = (7 - 21 = 14), J4 = ( 9 - 14 = 5), J5 = (4 - 5 = 1)</b>.</li>
              <li>Now that we got the <b>turnaround-time</b> of all of the jobs we can now calculate the waiting time of each job. This is done by subtracting the <b>turnaround-time and the burst time</b> of each jobs</li>
              <h4>Waiting Time</h4>
              <li>With that, let's calculate the <b>waiting time</b> for each job.</li>
              <li>For <b>J1</b>, we can see that it has a <b>turnaround time of 9 and a burst time of 8</b>. By subtracting those two, we get a 1 as an answer.Now lets do the rest of the jobs.</li>
              <li>For <b>J2</b>,it has a <b>turnaround time of 20</b> and a <b>burst time of 9 </b>so <b>J2 = (20 - 9 = 11)</b><b>J3 = (14 - 7 = 7), j4 = (5 - 5 = 0), j5 = (1 - 1 = 0)</b></li>
              <h2>Average turnaround time, average waiting time, CPU Utilization</h2>
              <img class="fcfsavg" src="SRTF-AVG.png" alt="fcfsavg">
              <h4>Average turnaround time</h4>
              <li>The calculations for the <b>Average turnaround time</b> are as follows: get the summation of <b>turnaround time</b> and divide the sum by how many items are there. In this case, the summation of <b>turnaround time is 49 divided by 5, which gives us 9.8</b>.</li>
              <li>Next is the <b>average waiting time</b>. It's just as simple: we're going to do the same thing as we did for the average turnaround time. so it will be the summation of <b>Waiting time 19 divided by 5, which gives us 3.8 as the answer</b></li>
              <li>Now for the CPU utilization. In this one, we are going to need the sum of our burst time, divide it by our total completion time, and multiply it by 100. So in this case, the <b>summation of burst time is 30; divide it by our end time, which is 30; then multiply by 100</b>, we get a total of <b>100% CPU-Utilization</b>.</li>
            </ul>
          </div>
        </div>
      </div>
    </section>

    <section class="container py-5" id="PRIO"> <!-- Issue on description -->
      <div class="row mt-4 py-3">
        <div class="col-12 d-flex flex-column text-right justify-content-right" id="paragraph">
          <h2>Priority(Preemptive)</h2>  
          <h5 class="text-secondary fw-normal py-2 Lucida Console">The simplest CPU scheduling algorithm, FCFS (First Come, First Serve), prioritizes processes based on their arrival times, utilizing a FIFO queue. As processes enter the ready queue, their PCBs are appended to the queue's tail. When the CPU becomes available, the process at the head of the queue is allocated the CPU and subsequently removed from the queue. FCFS can be either preemptive or non-preemptive, executing tasks in the order they arrive. While easy to implement, FCFS may result in high wait times and is less efficient, making it better suited for batch systems where longer process durations are tolerable.</h5>
            <img class = fcfspic src="PRIO-PIC.png" alt="fcfspic">
            <h5>So let's work on some examples from the given picture above and break it down bit by bit.</h5>
            <ul class="steps">
              <h2>Gantt Chart</h2>
              <li>The first would be to solve for the completion time, and this can be done by using a gantt chart. With both the arrival time and the given time, we could use that for the gantt chart.</li>
              <li>So using the arrival time of the processes, we have to process the one who came earlier, so it's going to be <b>J1</b> as it's the one who came first with the arrival time of 0.</li>
              <li>Then we have to process the <b>J1</b> with its burst time of 8.</li>
              <li>After we processed the first job, as you can see, we ended it at 8. Within those 8 came 2 jobs, which were <b>J3</b> and <b>J5</b>, which have a burst time of 7 and 4, respectively.</li>
              <li>To know which one to process first in a queue of jobs in the <b> First Come First Serve Algorithm </b> we have to use the arrival time of the queued jobs.</li>
              <li>In this case we would process the <b>J5</b> first because it arrived much earlier than the <b>J3</b>.</li>
              <li>Then we would use all of the burst time of <b>J5</b>, and the process ended at 9, then another job arrived, which is the j4.</li>
              <li>Using the same criteria we used earlier for multiple queued jobs, we would process the one who arrived first, which in this case is <b>J3</b>, which ended at 16. Inside those 16 then arrived another job, which is <b>J2</b>.</li>
              <li>Then we'll use the criteria again, which in this case is <b>J4</b> because it arrived first than <b>j2</b>. After we processed <b>J4</b>, which ended at 21, no other job arrived, so we will process the remaining job, <b>J2</b>, which ended at 30.</li>
              <h2>Turnaround Time and Waiting Time</h2>
              <h4>Turnaround-Time</h4>
              <li>Now that our Gantt chart is done, we can now solve the remaining parts of the table, which are the <b>turnaround time and waiting time.</b></li>
              <li>First would be the <b>turnaround time</b>, which we can solve by subtracting the <b>completion time</b> of the job from its <b>arrival time</b>.</li>
              <li>Now that we know the equation for the turnaround time, we can now calculate the turnaround time for each job.</li>
              <li>So we have <b>J1</b>, which has an <b>arrival time of 0</b> and a <b>completion time of 8</b>. Using the formula for the <b>turnaround-time (0-8)</b>, the answer would be 8. Now do the same for the others. <b>J2 = (10 - 30 = 20), J3 = (7 - 16 = 9), J4 = ( 9 - 21 = 12), J5 = (4 - 9 = 5)</b>.</li>
              <li>Now that we got the <b>turnaround-time</b> of all of the jobs we can now calculate the waiting time of each job. This is done by subtracting the <b>turnaround-time and the burst time</b> of each jobs</li>
              <h4>Waiting Time</h4>
              <li>With that, let's calculate the <b>waiting time</b> for each job.</li>
              <li>For <b>J1</b>, we can see that it has a <b>turnaround time of 8 and a burst time of 8</b>. By subtracting those two, we get a 0 as an answer.Now lets do the rest of the jobs.</li>
              <li>For <b>J2</b>,it has a <b>turnaround time of 20</b> and a <b>burst time of 9 </b>so <b>J2 = (20 - 9 = 11)</b><b>J3 = (9 - 7 = 2), j4 = (12 - 5 = 7), j5 = (5 - 1 =4)</b></li>
              <h2>Average turnaround time, average waiting time, CPU Utilization</h2>
              <img class="fcfsavg" src="PRIO-AVG.png" alt="fcfsavg">
              <h4>Average turnaround time</h4>
              <li>The calculations for the <b>Average turnaround time</b> are as follows: get the summation of <b>turnaround time</b> and divide the sum by how many items are there. In this case, the summation of <b>turnaround time is 54 divided by 5, which gives us 10.8</b>.</li>
              <li>Next is the <b>average waiting time</b>. It's just as simple: we're going to do the same thing as we did for the average turnaround time. so it will be the summation of <b>Waiting time 24 divided by 5, which gives us 4.8 as the answer</b></li>
              <li>Now for the CPU utilization. In this one, we are going to need the sum of our burst time, divide it by our total completion time, and multiply it by 100. So in this case, the <b>summation of burst time is 30; divide it by our end time, which is 30; then multiply by 100</b>, we get a total of <b>100% CPU-Utilization</b>.</li>
            </ul>
          </div>
        </div>
      </div>
    </section>

    <section class="container py-5" id="NON-PRIO"> <!-- Issue on description/ pictures-->
      <div class="row mt-4 py-3">
        <div class="col-12 d-flex flex-column text-right justify-content-right" id="paragraph">
          <h2>Priority(Non-Preemptive)</h2>  
          <h5 class="text-secondary fw-normal py-2 Lucida Console">Priority scheduling is a non-preemptive algorithm commonly used in batch systems. It operates by assigning each process an arrival time and priority, with the first process scheduled being the one with the lowest arrival time. If multiple processes share the same arrival time, the one with the highest priority is scheduled first. If two processes have the same priority, the one with the lower process number is scheduled first. This process continues until all processes have been executed. It’s important to note that the priority number’s significance (whether a lower or higher number indicates a higher priority) will be clearly stated in the question. Once all processes have arrived, they can be scheduled based on their priority. This approach ensures efficient and fair process scheduling.</h5>
            <img class = fcfspic src="PRIO-PIC.png" alt="fcfspic">
            <h5>So let's work on some examples from the given picture above and break it down bit by bit.</h5>
            <ul class="steps">
              <h2>Gantt Chart</h2>
              <li>The first job to arrive at the queue is J1, so we have to process all of its burst time. That ends at time 8, and within that time, two jobs arrive at the queue, which are J5 and J3.</li>
              <li>Now that we have multiple jobs in the queue, we will have to use the criteria for priority, which states that we have to process the one who has a higher priority than the others, with 1 being the highest priority.</li>
              <li>So back to the example, we can see two jobs in the queue, J5 and J3. J5 has a priority number of 1, and J3 has the same priority number, 1. To break the tie between the two, we would look at the next criteria, which is the burst time. The lower the burst time, the higher the priority to be processed, the same as the Shortest Job First Scheduling Algorithm.</li>
              <li>So in this case, we would process J5 first, as it has a lower burst time than J3. After we processed J5, we arrived at time 9, where another job arrived, which was J4.</li>
              <li>Again, we have multiple jobs in the queue, so we would use the criteria for the priority scheduling algorithm to know which one to process first. As we can see in the table above, J3 has a priority number of 1 and J4 has a priority number of 4, so we would have to process J3 first as it has a higher priority value than J4, ending its burst time at time 16; another job arrived, which is J2.</li>
              <li>J2 has a priority number of 2 and J4 has a priority number of 4, so we will have to process J2 first, ending its burst time at time 25, and finally processing the final job in the queue, which is J4, ending its burst time at time 30.</li>
              <h2>Turnaround Time and Waiting Time</h2>
              <h4>Turnaround-Time</h4>
              <li>Now that our Gantt chart is done, we can now solve the remaining parts of the table, which are the <b>turnaround time and waiting time.</b></li>
              <li>First would be the <b>turnaround time</b>, which we can solve by subtracting the <b>completion time</b> of the job from its <b>arrival time</b>.</li>
              <li>Now that we know the equation for the turnaround time, we can now calculate the turnaround time for each job.</li>
              <li>So we have <b>J1</b>, which has an <b>arrival time of 0</b> and a <b>completion time of 8</b>. Using the formula for the <b>turnaround-time (0-8)</b>, the answer would be 8. Now do the same for the others. <b>J2 = (10 - 25 = 15), J3 = (7 - 16 = 9), J4 = ( 9 - 30 = 21), J5 = (4 - 9 = 5)</b>.</li>
              <li>Now that we got the <b>turnaround-time</b> of all of the jobs we can now calculate the waiting time of each job. This is done by subtracting the <b>turnaround-time and the burst time</b> of each jobs</li>
              <h4>Waiting Time</h4>
              <li>With that, let's calculate the <b>waiting time</b> for each job.</li>
              <li>For <b>J1</b>, we can see that it has a <b>turnaround time of 8 and a burst time of 8</b>. By subtracting those two, we get a 0 as an answer.Now lets do the rest of the jobs.</li>
              <li>For <b>J2</b>,it has a <b>turnaround time of 20</b> and a <b>burst time of 9 </b>so <b>J2 = (15 - 9 = 6)</b><b>J3 = (9 - 7 = 2), j4 = (21 - 5 = 16), j5 = (5 - 1 = 4)</b></li>
              <h2>Average turnaround time, average waiting time, CPU Utilization</h2>
              <img class="fcfsavg" src="PRIO-AVG.png" alt="fcfsavg">
              <h4>Average turnaround time</h4>
              <li>The calculations for the <b>Average turnaround time</b> are as follows: get the summation of <b>turnaround time</b> and divide the sum by how many items are there. In this case, the summation of <b>turnaround time is 58 divided by 5, which gives us 11.6</b>.</li>
              <li>Next is the <b>average waiting time</b>. It's just as simple: we're going to do the same thing as we did for the average turnaround time. so it will be the summation of <b>Waiting time 28 divided by 5, which gives us 5.6 as the answer</b></li>
              <li>Now for the CPU utilization. In this one, we are going to need the sum of our burst time, divide it by our total completion time, and multiply it by 100. So in this case, the <b>summation of burst time is 30; divide it by our end time, which is 30; then multiply by 100</b>, we get a total of <b>100% CPU-Utilization</b>.</li>
            </ul>
          </div>
        </div>
      </div>
    </section>

    <section class="container py-5" id="RR"> <!-- Issue on description/ pictures-->
      <div class="row mt-4 py-3">
        <div class="col-12 d-flex flex-column text-right justify-content-right" id="paragraph">
          <h2>Round Robin</h2>  
          <h5 class="text-secondary fw-normal py-2 Lucida Console">The simplest CPU scheduling algorithm, FCFS (First Come, First Serve), prioritizes processes based on their arrival times, utilizing a FIFO queue. As processes enter the ready queue, their PCBs are appended to the queue's tail. When the CPU becomes available, the process at the head of the queue is allocated the CPU and subsequently removed from the queue. FCFS can be either preemptive or non-preemptive, executing tasks in the order they arrive. While easy to implement, FCFS may result in high wait times and is less efficient, making it better suited for batch systems where longer process durations are tolerable.</h5>
            <img class = fcfspic src="FCFS-PIC.png" alt="fcfspic">
            <h5>So let's work on some examples from the given picture above and break it down bit by bit.</h5>
            <ul class="steps">
              <h2>Gantt Chart</h2>
              <li>The first would be to solve for the completion time, and this can be done by using a gantt chart. With both the arrival time and the given time, we could use that for the gantt chart.</li>
              <li>So using the arrival time of the processes, we have to process the one who came earlier, so it's going to be <b>J1</b> as it's the one who came first with the arrival time of 0.</li>
              <li>Then we have to process the <b>J1</b> with its burst time of 8.</li>
              <li>After we processed the first job, as you can see, we ended it at 8. Within those 8 came 2 jobs, which were <b>J3</b> and <b>J5</b>, which have a burst time of 7 and 4, respectively.</li>
              <li>To know which one to process first in a queue of jobs in the <b> First Come First Serve Algorithm </b> we have to use the arrival time of the queued jobs.</li>
              <li>In this case we would process the <b>J5</b> first because it arrived much earlier than the <b>J3</b>.</li>
              <li>Then we would use all of the burst time of <b>J5</b>, and the process ended at 9, then another job arrived, which is the j4.</li>
              <li>Using the same criteria we used earlier for multiple queued jobs, we would process the one who arrived first, which in this case is <b>J3</b>, which ended at 16. Inside those 16 then arrived another job, which is <b>J2</b>.</li>
              <li>Then we'll use the criteria again, which in this case is <b>J4</b> because it arrived first than <b>j2</b>. After we processed <b>J4</b>, which ended at 21, no other job arrived, so we will process the remaining job, <b>J2</b>, which ended at 30.</li>
              <h2>Turnaround Time and Waiting Time</h2>
              <h4>Turnaround-Time</h4>
              <li>Now that our Gantt chart is done, we can now solve the remaining parts of the table, which are the <b>turnaround time and waiting time.</b></li>
              <li>First would be the <b>turnaround time</b>, which we can solve by subtracting the <b>completion time</b> of the job from its <b>arrival time</b>.</li>
              <li>Now that we know the equation for the turnaround time, we can now calculate the turnaround time for each job.</li>
              <li>So we have <b>J1</b>, which has an <b>arrival time of 0</b> and a <b>completion time of 8</b>. Using the formula for the <b>turnaround-time (0-8)</b>, the answer would be 8. Now do the same for the others. <b>J2 = (10 - 30 = 20), J3 = (7 - 16 = 9), J4 = ( 9 - 21 = 12), J5 = (4 - 9 = 5)</b>.</li>
              <li>Now that we got the <b>turnaround-time</b> of all of the jobs we can now calculate the waiting time of each job. This is done by subtracting the <b>turnaround-time and the burst time</b> of each jobs</li>
              <h4>Waiting Time</h4>
              <li>With that, let's calculate the <b>waiting time</b> for each job.</li>
              <li>For <b>J1</b>, we can see that it has a <b>turnaround time of 8 and a burst time of 8</b>. By subtracting those two, we get a 0 as an answer.Now lets do the rest of the jobs.</li>
              <li>For <b>J2</b>,it has a <b>turnaround time of 20</b> and a <b>burst time of 9 </b>so <b>J2 = (20 - 9 = 11)</b><b>J3 = (9 - 7 = 2), j4 = (12 - 5 = 7), j5 = (5 - 1 =4)</b></li>
              <h2>Average turnaround time, average waiting time, CPU Utilization</h2>
              <img class="fcfsavg" src="FCFS-PIC.png" alt="fcfsavg">
              <h4>Average turnaround time</h4>
              <li>The calculations for the <b>Average turnaround time</b> are as follows: get the summation of <b>turnaround time</b> and divide the sum by how many items are there. In this case, the summation of <b>turnaround time is 54 divided by 5, which gives us 10.8</b>.</li>
              <li>Next is the <b>average waiting time</b>. It's just as simple: we're going to do the same thing as we did for the average turnaround time. so it will be the summation of <b>Waiting time 24 divided by 5, which gives us 4.8 as the answer</b></li>
              <li>Now for the CPU utilization. In this one, we are going to need the sum of our burst time, divide it by our total completion time, and multiply it by 100. So in this case, the <b>summation of burst time is 30; divide it by our end time, which is 30; then multiply by 100</b>, we get a total of <b>100% CPU-Utilization</b>.</li>
            </ul>
          </div>
        </div>
      </div>
    </section>
    

    <script src="info.js"></script>
     <!-- Footer -->
     
     <!-- Bootstrap script link -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js" integrity="sha384-w76AqPfDkMBDXo30jS1Sgez6pr3x5MlQ1ZAGC+nuZB+EYdgRZgiwxhTBTkF7CXvN" crossorigin="anonymous"></script>
  </body>
</html>